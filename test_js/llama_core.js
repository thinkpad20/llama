// Generated by CoffeeScript 1.7.1
(function() {
  var Cons, ConstructorNotFoundError, DerefRangeError, End, Exception, Just, LlamaObject, LookupError, NoAttributeError, Nothing, PatternMatchError, TypeError, is_instance, print, println, show, str_to_list, _, _append, _divide, _minus, _plus, _throw, _times;

  _ = require('underscore');

  Object.prototype.deref = function(idx) {
    if (idx === 0) {
      return this;
    }
    return _throw(PatternMatchError());
  };

  _throw = function(exc) {
    throw JSON.stringify(exc.get_attr('Exception', 'trace'));
  };

  LlamaObject = (function() {
    function LlamaObject(___type_name, ___constr_name, ___values, ___attrs, parent, affect) {
      this.___type_name = ___type_name;
      this.___constr_name = ___constr_name;
      this.___values = ___values != null ? ___values : [];
      this.___attrs = ___attrs != null ? ___attrs : {};
      this.parent = parent;
      if (affect != null) {
        affect(this);
      }
    }

    LlamaObject.prototype.deref = function(constr_name, idx) {
      if (!_.isString(constr_name)) {
        _throw(TypeError('constr_name needs to be a string!'));
      }
      if (!_.isNumber(idx)) {
        _throw(TypeError('idx needs to be a number!'));
      }
      if (this.___constr_name === constr_name) {
        if (idx < this.___values.length) {
          return this.___values[idx];
        } else {
          return _throw(DerefRangeError(idx, this));
        }
      } else if (this.parent != null) {
        return this.parent.deref(constr_name, idx);
      } else {
        return _throw(ConstructorNotFoundError(constr_name, this));
      }
    };

    LlamaObject.prototype.get_attr = function(constr_name, key) {
      if (!_.isString(constr_name)) {
        _throw(TypeError('constr_name needs to be a string!'));
      }
      if (!_.isString(key)) {
        _throw(TypeError('key needs to be a string!'));
      }
      if (this.___constr_name === constr_name) {
        if (this.___attrs[key] != null) {
          return this.___attrs[key];
        } else {
          return _throw(NoAttributeError(key, this));
        }
      } else if (this.parent != null) {
        return this.parent.get_attr(constr_name, key);
      } else {
        return _throw(ConstructorNotFoundError(constr_name, this));
      }
    };

    return LlamaObject;

  })();

  is_instance = function(obj, name) {
    if (_.isArray(obj && name === 'Array')) {
      return true;
    }
    if (_.isNumber(obj && name === 'Num')) {
      return true;
    }
    if (_.isString(obj && name === 'Str')) {
      return true;
    }
    if (_.isBoolean(obj && name === 'Bool')) {
      return true;
    }
    if (obj.___type_name === name) {
      return true;
    }
    return (obj.___parent != null) && is_instance(obj.___parent, name);
  };

  Exception = function(msg) {
    return new LlamaObject('Exception', 'Exception', [msg], {}, null, function(self) {
      return self.___attrs.trace = new Error(msg).stack;
    });
  };

  NoAttributeError = function(attr, obj) {
    var parent;
    parent = Exception("Attribute " + (show(attr)) + " not found on object " + (show(obj)));
    return new LlamaObject('NoAttributeError', 'NoAttributeError', [attr], {}, parent);
  };

  DerefRangeError = function(idx, obj) {
    var parent;
    parent = Exception("Index " + (show(idx)) + " out of range on object " + (show(obj)));
    return new LlamaObject('NoAttributeError', 'NoAttributeError', [attr], {}, parent);
  };

  ConstructorNotFoundError = function(constr_name, obj) {
    var parent;
    parent = Exception("Constructor " + (show(constr_name)) + " not found on object " + (show(obj)));
    return new LlamaObject('ConstructorNotFoundError', 'ConstructorNotFoundError', [constr_name, obj], {}, parent);
  };

  LookupError = function(key) {
    var parent;
    parent = Exception(_append(_append('Key ')(show(key)))(' was not found'));
    return new LlamaObject('LookupError', 'LookupError', [key], {}, parent);
  };

  PatternMatchError = function(pat) {
    return function(val) {
      var parent, s;
      s = _append("Couldn't match value ")(show(val));
      s = _append(s)(' with pattern ');
      s = _append(s)(show(pat));
      parent = Exception(s);
      return new LlamaObject('PatternMatchError', 'PatternMatchError', [pat, val], {}, parent);
    };
  };

  TypeError = function(msg) {
    var parent;
    parent = Exception(msg);
    return new LlamaObject('TypeError', 'TypeError', [msg], {}, parent);
  };

  Number.prototype.get_attr = function(name) {
    if (this[name] != null) {
      return this[name];
    }
    return _throw(NoAttributeError(name));
  };

  String.prototype.get_attr = function(name) {
    if (this[name] != null) {
      return this[name];
    }
    return _throw(NoAttributeError(name));
  };

  Function.prototype._call = function(arg) {
    if (_.isArray(arg)) {
      return this.apply(null, arg);
    } else {
      return this(arg);
    }
  };

  Nothing = new LlamaObject('Maybe', 'Nothing');

  Just = function(_a) {
    return new LlamaObject('Maybe', 'Just', [_a]);
  };

  End = new LlamaObject('List', 'End');

  Cons = function(a) {
    return function(next) {
      return new LlamaObject('List', 'Cons', [a, next]);
    };
  };

  _plus = function(x) {
    return function(y) {
      return x + y;
    };
  };

  _minus = function(x) {
    return function(y) {
      return x - y;
    };
  };

  _times = function(x) {
    return function(y) {
      return x * y;
    };
  };

  _divide = function(x) {
    return function(y) {
      return x / y;
    };
  };

  _append = function(a) {
    return function(b) {
      var next, val;
      if (_.isNumber(a) && _.isNumber(b)) {
        return a + b;
      } else if (_.isString(a) && _.isString(b)) {
        return a + b;
      } else if (is_instance(a, 'List') && is_instance(b, 'List')) {
        if (a.___constr_name === 'End') {
          return b;
        } else {
          val = a.deref('Cons', 0);
          next = a.deref('Cons', 1);
          return Cons(val)(_append(next)(b));
        }
      } else {
        throw TypeError("_append not implemented for " + a + ", " + b);
      }
    };
  };

  str_to_list = function(str) {
    var c, res, _i, _len, _ref;
    res = End;
    _ref = str.split("").reverse().join("");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      res = Cons(c)(res);
    }
    return res;
  };

  show = function(x) {
    return JSON.stringify(x);
  };

  println = console.log;

  print = process.stdout.write;

  exports.LlamaObject = LlamaObject;

  exports.is_instance = is_instance;

  exports.Exception = Exception;

  exports.LookupError = LookupError;

  exports.PatternMatchError = PatternMatchError;

  exports.ConstructorNotFoundError = ConstructorNotFoundError;

  exports.NoAttributeError = NoAttributeError;

  exports.Nothing = Nothing;

  exports.Cons = Cons;

  exports.End = End;

  exports.Just = Just;

  exports._throw = _throw;

  exports.show = show;

  exports.println = println;

  exports.print = print;

  exports._plus = _plus;

  exports._minus = _minus;

  exports._times = _times;

  exports._divide = _divide;

  exports._append = _append;

  exports.str_to_list = str_to_list;

}).call(this);
