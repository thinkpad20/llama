# Some feature ideas:


# function calls are left-associative:

foo bar == foo (bar)
foo bar baz = foo(bar)(baz)
foo (bar, baz) == foo(bar, baz)
foo bar, baz == (foo bar, baz)

# dot reference is left associative, higher than function call
foo.bar == foo.bar
foo.bar baz == foo.bar(baz)
foo bar.baz == foo(bar.baz)
(foo bar).baz == foo(bar).baz
foo bar.baz qux = foo(bar.baz)(qux)

# functions are block-structured, declare argument types:

foo (bar: [a], baz: [a]) =
  blob = bar ++ baz
  if length blob > 3
    print "oh crap"
  	max(head bar, head baz)
  else
  	blob[3]

# unary operators are just functions
apply1 (f: Num -> Num) = f 10
assert(apply1 (~) == ~10)

# binary operators are functions which take tuples as arguments
apply2 = (f: (Num, Num) -> Num) = f (10, 23)
assert(apply2 (*) == 230)
(++) = (str1: String, str2: String) =>
  # mut to create mutable version, will make a copy of operand
  result = mut str1
  for char in str2 do result.push! char
  fix result # returns an immutable version of result

# make a mutable version, will come in handy (returns itself)
append! (str: mut String, str2: String) = str := str ++ str2; str

# functions can be overloaded
assert (2 * 3 == 6) 
(*) = (str: String, num: Num) =>
  result = mut ""
  for n in [1..num] do result.append! str
  fix result
assert ("hello" * 3 == "hellohellohello")

# it's a verrrry common pattern to have some mutable accumulator, so
# let's create a syntactic sugar for that, which should also help
# prevent errors
repl = (str: String, count: Num) =>
  with result = "" do for n in [1..count] do result.append! str

# we can use this as any expression
foo = with result = 0 do result := result + 1
assert (foo == 1)
bar = with result = 1 do for i in [1..5] do result.times! i
assert (bar == 120)
product = list: [Num] => with result = 1 do for i in list do result.times! i
assert (bar == product [1..5])

# we might want to make declarations like this
(str: String) + (c: Char) = with result = str do result.push! c
assert ("hello" + "!" == "hello!")
# or go crazy and overload it further
(str: String) + (n: Num) = with result = str do result.append! (toString n)
assert ("catch-" + 22 == "catch-22")

# if we don't want to fix on return:
repl2 = (str: String, count: Num) =>
  with! result = "" do for n in [1..count] do result.append! str

# that's equivalent to
repl2 = (str: String, count: Num) =>
  result = mut ""
  for n in [1..count] do result.append! str
  result

# and this means we can mutate it:
assert ((repl2 "hey" 5).append! "!" == "heyheyheyheyhey!")

# Curried functions are simple
map (f: a -> b) (vec: [a]) =
  with result = [] do for a in vec do result.push! (f a)

# lambdas are also simple
add1 = map (x: Num => x + 1)
addPairs = map (+)
print(add1 [1..10])
print(addPairs(zip([1,2,3], [4,5,6]))

# we can also define map as follows:
map2 = f: a->b => vec: [a] => ...

# or we could define it with pattern matching
map3 (f: a -> b) (vec: [a]) = case vec of
  [] => [] | a::as => f a :: map3! f as

# or if we want TCO:
map4 (f: a -> b) (vec: [a]) =
  loop = (acc: [b], []) => acc
       | (acc: [b], (a::as): [a]) => loop (f a::acc, as)
  loop ([], vec)

# we can have a muting map if we want:
map! (vec: mut [a], f: a -> b) = 
  for i in [0..vec.length-1] do vec[i] := f (vec i); vec

# should we be smart enough to figure out that `reverse [1]` is a function
# call on the vector [1], and `vector[1]` is an array index on `vector`?
# With explicit types, this is possible.
# Also important to note that if `vec[i]` returns a *copy*, then `vec[i] := 2`
# doesn't have any mutation effect. So `vec[i]` has to give us a reference to
# something which can be updated. Essentially this is what we mean when we say
# `:=`... it's not a function. Or if it is one, it's built-in with this signature:
(:=) : (mut a, a) -> ()

slice (v: [a], indices: [Num]) =
  result = mut []
  for n in indices do result.push v[n]
  result

vector = [0..10].map(x -> x ^ 2)
assert (vector[0] == 0)
assert (vector.slice [2] == [4])
assert (vector.slice [4..7] == [16, 25, 36, 49])

# these symbols can be used to make functions:
# +-*/%$|><=
# as long as they don't make up the key symbols.
(<|) = (func: a -> b, arg: a) => func arg
(|>) = (arg: a, func: a -> b) => func arg
assert(foo bar <| baz qux == foo bar (baz qux))
assert(baz qux |> foo bar == foo bar (baz qux))

# simple types
struct Point(x: Num, y: Num)
struct Circle (center: Point, radius: Num)
struct Rectangle (topLeft: Point, bottomRight: Point)

# pure function
clone (c: Circle) = Circle(c.center, c.radius)

# overloaded pure function
(+) = (p1: Point, p2: Point) => Point(p1.x + p2.x, p1.y + p2.y)
assert(Point(3,4) + Point(9, 1) == Point(12, 5))

# impure function (! by convention)
move! (c: mut Circle, d: Point) = c.center := c.center + d; c

# overloaded impure function
move! (c: mut Circle, dx: Num, dy: Num) = c.move!(Point(dx, dy))

# impure, but only because of IO
report (c: Circle) = print("area is #{c.area}, location is #{c.center}")
assert(c.report === report) # === is equality by pointer, always works

# optional args get wrapped and appear as option types
resize! (c: mut Circle, @scale: Num, @newR: Num) = 
  case scale of
  	Some scale => c.radius := c.radius * scale 
  	Nothing => case newR of
  	  Some r => c.radius := r
  	  Nothing => () # could optionally throw error here

c = mut Circle(Point(0,0), 0.565)
c.report() # area is 1.0, location is Point(0, 0)
c.move!(Point(2, 3)).report() # area is 1.0, location is Point(2, 3)
c.resize!(scale=4)
report(move!(c, -3, 2)) # area is 16.0, location is Point(-1, 5)"
c.resize!(r=3).move!(1, -1) |> report # area is 28.2, location is Point(0, 4)


# traits (type classes)

trait Mobile order 1 =
  move : Self -> Self
  move! : mut Self -> Self

# not sure if we should have higher-order type classes... gets ugly fast.

trait Functor order 2 = 
  map : (Self a, a -> b) -> Self b

trait MutFunctor order 2 =
  map! : (mut Self a, a -> b) -> ()

trait Applicative extends Functor =
  pure : a -> Self a
  apply : (Self a, Self (a -> b)) -> Self b

trait Monad extends Applicative = 
  lift : a -> Self a
  bind : (Self a, a -> Self b) -> Self b

Option as Functor =
  map = (Nothing, _) => Nothing
      | (Some x, f) => Some (f x)

Option as Applicative =
  pure a = Some a
  apply = (Nothing, _) => Nothing
        | (Some x, Nothing) => Nothing
        | (Some x, Some f) => Some (f x)

Option as Monad =
  lift a = Some a
  bind = (Nothing, _) => Nothing
       | (Some x, f)  => f x

# What about objects acting like functions? That could be interesting.
# This introduces the idea of type classes which are parameterized by some
# type (in this case, the argument type with which they're called)
trait Function t = # of course, the return type is unset...
  call : (self, arg: t) -> u

[a] as Function Num = 
  call (self, n) = self{!n}

[a] as Function [Num] = 
  call (self, indices: [Num]) = self.slice indices

assert ([1..10] 4 == 5)
assert ([1..10] [2,5,4] == [3,6,5])

# how about a map?
[a] as Function (a -> b) =
  call (self, f) = self.map f

assert (["hello", "world"] allCaps == ["HELLO", "WORLD"])

Num as Function Num = 
  call (self, n) = self * n

assert (22 3 == 66)
x = 4; y = 5
assert (2x + 3y == 23)

Num as Function (Num -> a) =
  call (self, f) = f self

replicate times a = 
  result = mut []
  for n in [1..times] do result.push! a
  fix result

twice = replicate 2

assert(2 twice == [2,2])

"hello" "world" # Error: `String` doesn't implement `Function String`

# make String an instance of Function:
String as Function String = call (str1, str2) = str1 ++ str2

# now it will work
assert ("hello " "world!" == "hello world!")

# one thing we can do is when dealing with immutable vectors, use a 
# Clojure-style implementation, but when using mutable vectors, use a
# C-style implementation. Since we'll always know which is which, this
# should be possible and maintain the advantages of each use case. As
# always, `mut` will create a mutable copy of its argument: no immutable
# object can be made mutable, so immutable objects are always safe to use.

foo = [1,2,3] # foo is clojure-style
bar = mut [1,2,3] # bar is C-style
baz = mut foo # baz is C-style, with a copy of foo's contents
qux = fix bar # qux is Clojure-style, with a copy of foo's contents

struct List a = End | (::) (value: a, next: List a)

# a `!` after the `[` indicates a linked list, syntactic sugar
list = [! 1, 2, 3] # linked list, immutable
assert(list == 1 :: 2 :: 3 :: End)

list2 = mut list # mutable linked list, deep copied...

# how about a replace function?
replace! (list: mut [!a], toReplace: a, toReplaceWith: a) = 
  runner = list # runner grabs a copy of the reference
  while runner != [!]
    if runner.value == toReplace then runner.value := toReplaceWith

list2.replace!(1, 4)
assert(list2 == [! 4, 2, 3])

toList (str: String) =
  mut result = [!]
  for char in str.reverse() do result := char :: result
  fix result

fello = fix (mut "hello".toList()).replace!('h', 'f')
assert (fello == "fello")

